import path from 'path';
import chokidar from 'chokidar';

let prevPath: string | undefined = undefined;
let DIR_WATCHER: chokidar.FSWatcher | undefined = undefined;

export default async (
  WatchPath: string,
  setFiles: any,
  setFolders: any,
  sortBy: string,
  sortByType: 'ascending' | 'descending'
) => {
  if (prevPath) DIR_WATCHER.close();
  else if (prevPath === WatchPath) return null;

  DIR_WATCHER = chokidar.watch(WatchPath, {
    persistent: true,
    ignoreInitial: false,
    followSymlinks: false,
    disableGlobbing: false,
    interval: 100,
    binaryInterval: 300,
    alwaysStat: false,
    depth: 0,
    awaitWriteFinish: {
      stabilityThreshold: 2000,
      pollInterval: 100,
    },

    ignorePermissionErrors: false,
    atomic: true, // or a custom 'atomicity delay', in milliseconds (default 100)
  });

  prevPath = WatchPath;

  let COMPARER: any = null;

  switch (sortByType) {
    case 'ascending':
      if (sortBy === 'name')
        COMPARER = (val1, val2) => val1.name.localeCompare(val2.name);
      else COMPARER = (val1, val2) => val1.sortBy - val2.sortBy;
      break;
    case 'descending':
      if (sortBy === 'name')
        COMPARER = (val1, val2) => val2.name.localeCompare(val1.name);
      else COMPARER = (val1, val2) => val2.sortBy - val1.sortBy;
      break;
  }
  // WHEN A FILE IS ADDED/DETECTED
  DIR_WATCHER.on('add', (filePath: string, stats: any) => {
    setFiles((prev) => {
      const fileName = filePath.slice(filePath.lastIndexOf(path.sep) + 1);

      return [...prev, { name: fileName, sortBy: stats[sortBy] }].sort(
        COMPARER
      );
    });
  });

  // THIS VARIALBE IS USED TO SKIP A EMPTY DIRECTORY GENERATED BY DIR_WATCHER, if you wanna try what does it do just change it's value to > 0 [zero]
  let tmpCount = 0;

  // WHEN A FOLDER IS ADDED/DETECTED
  DIR_WATCHER.on('addDir', (folderPath, stats: any) => {
    if (tmpCount) {
      setFolders((prev) => {
        const folderName = folderPath.slice(
          folderPath.lastIndexOf(path.sep) + 1
        );

        return [
          ...prev,
          {
            name: folderName,
            sortBy: stats[sortBy],
          },
        ].sort(COMPARER);
      });
    } else tmpCount++;
  });

  // WHEN A FILE IS DELETED
  DIR_WATCHER.on('unlink', (filePath: any) => {
    setFiles((prev: Array<any>) => {
      const fileName = filePath.slice(filePath.lastIndexOf(path.sep) + 1);
      return prev.filter((FILE) => FILE.name !== fileName);
    });
  });

  // WHEN A FOLDER IS DELETED
  DIR_WATCHER.on('unlinkDir', (folderPath: any) => {
    setFolders((prev: Array<any>) => {
      const folderName = folderPath.slice(folderPath.lastIndexOf(path.sep) + 1);
      return prev.filter((val) => val.name !== folderName);
    });
  });

  return null;
};
